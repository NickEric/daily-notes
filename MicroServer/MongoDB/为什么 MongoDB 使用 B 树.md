# 为什么 MongoDB 使用 B 树

MySQL 中使用 B+ 树是因为 B+ 树只有叶节点会存储数据，将树中的每一个叶节点通过指针连接起来就能实现顺序遍历，而遍历数据在关系型数据库中非常常见，所以这么选择是完全没有问题的。



但是 MongoDB 认为查询单个数据记录远比遍历数据更加常见，由于 B 树的非叶结点也可以存储数据，所以**查询一条数据所需要的平均随机 IO 次数会比 B+ 树少**，使用 B 树的 MongoDB 在类似场景中的查询速度就会比 MySQL 快。



- 作为非关系型的数据库，MongoDB 对于遍历数据的需求没有关系型数据库那么强，它追求的是读写单个记录的性能；
- 大多数的数据库面对的都是读多写少的场景，B 树与 LSM 树在该场景下有更大的优势；



假设有如下一条查询语句：

```mysql
SELECT * FROM comments WHERE post_id = 1
```

上述查询其实并不是范围查询，它没有使用 `>`、`<` 等表达式，但是它却会在 `comments` 表中查询一系列的记录，如果 `comments` 表上有索引 `post_id`，那么这个查询可能就会在索引中遍历相应索引，找到满足条件的 `comment`，这种查询也会受益于 MySQL B+ 树相互连接的叶节点，因为它能减少磁盘的随机 IO 次数。

MongoDB 作为非关系型的数据库，它从集合的设计上就使用了完全不同的方法，如果我们仍然使用传统的关系型数据库的表设计思路来思考 MongoDB 中集合的设计，写出类似如上所示的查询会带来相对比较差的性能：

```javascript
db.comments.find( { post_id: 1 } )
```

因为 B 树的所有节点都能存储数据，各个连续的节点之间没有很好的办法通过指针相连，所以上述查询在 B 树中性能会比 B+ 树差很多，但是这并不是一个 MongoDB 中推荐的设计方法，更合适的做法其实是使用嵌入文档，将 `post` 和属于它的所有 `comments` 都存储到一起：

```json
{
    "_id": "...",
    "title": "为什么 MongoDB 使用 B 树",
    "author": "draven",
    "comments": [
        {
            "_id": "...",
            "content": "你这写的不行"
        },
        {
            "_id": "...",
            "content": "一楼说的对"
        }
    ]
}
```

使用上述方式对数据进行存储时就不会遇到 `db.comments.find( { post_id: 1 } )` 这样的查询了，我们只需要将 `post` 取出来就会获得相关的全部评论，这种区别于传统关系型数据库的设计方式是需要所有使用 MongoDB 的开发者重新思考的，这也是很多人使用 MongoDB 后却发现性能不如 MySQL 的最大原因 —— 使用的姿势不对。





## 小结

MongoDB 最终选择使用 B 树的两个原因：

- MySQL 使用 B+ 树是因为数据的遍历在关系型数据库中非常常见，它经常需要处理各个表之间的关系并通过范围查询一些数据；但是 MongoDB 作为面向文档的数据库，与数据之间的关系相比，它更看重以文档为中心的组织方式，所以选择了查询单个文档性能较好的 B 树，这个选择对遍历数据的查询也可以保证可以接受的时延；
- LSM 树是一种专门用来优化写入的数据结构，它将随机写变成了顺序写显著地提高了写入性能，但是却牺牲了读的效率，这与大多数场景需要的特点是不匹配的，所以 MongoDB 最终还是选择读取性能更好的 B 树作为默认的数据结构；



原文:`https://draveness.me/whys-the-design-mongodb-b-tree/`