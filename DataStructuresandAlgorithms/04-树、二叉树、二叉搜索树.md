# 树、二叉树、二叉搜索树

# 树 Tree

链表缺点是查询慢，每次查询只能挨个遍历，于是出现了跳表这种结构，提升了查询效率。

如果将链表的一个 next 指针，变成多个 next 指针这样查询岂不是会快很多？

于是有了树 Tree 这种数据结构。

> Linked List 是特殊的 Tree
>
> Tree 是特殊的 Graph



二叉树遍历 Pre-order / In-order / Post-order

* 1）前序（Pre-order）：根-左-右
* 2）中序（In-order）：左-根-右
* 3）后序（Post-order）：左-右-根



## 二叉搜索树（Binary Search Tree）

普通树查询某个值也是需要遍历，时间复杂度为O(n)，和链表没区别，所以为了更快的查询，出现二叉搜索树。

将数据按照一定顺序排列，这样查询的时候就会比较方便。

二叉搜索树也称有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一颗控诉或者具有下列性质的二叉树：

* 1）左子树上**所有节点**的值均**小于**它的根节点的值；
* 2）右子树上**所有节点**的值均**大于**它的根节点的值；
* 3）以此类推：左右子树也分别为二叉查找树。

中序遍历：升序排列



常见操作

* 1）查询
  * 类似二分查找
* 2）插入新节点（新建）
  * 也是先查询，最后找不到这种节点但是最后停留的位置就是该节点需要插入的位置
* 3）删除
  * 如果删除掉某个关键节点（比如根节点），则需要找到刚好比这个节点大一点点的那个节点来替换该节点

时间复杂度都是 logn

演示 demo

```text
https://visualgo.net/zh/bst
```

**树相关的题目解法都是递归，为什么？**

因为树这个结构没有比较好的后继节点这种好循环的方式，最好的遍历方式就是对左右子树进进行递归遍历。