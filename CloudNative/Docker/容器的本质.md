# 容器的本质

## 1.概述

进程：一个程序运行起来后的计算机执行环境的总和，简单理解就是运行起来的程序。

**容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。**

对于 Docker 等大多数 Linux 容器来说，**Cgroups**用来制造约束的主要手段，而 **Namespace** 技术则是用来修改进程视图的主要方法。

**所以说，容器，其实是一种特殊的进程而已。**



可怜的容器，被Namespace欺骗，又被Cgroups限制，在这样的环境下，还发挥着自己生命的意义-与应用程序同生命周期，同生共死～



## 2.Namespace

Linux 中的PID=1的进程永远只能有一个，但是每个容器中查看都会有一个PID=1的进程。

这个就是通过PID Namespace实现的。

其实是一个障眼法，在容器中看起来该进程PID=1，实际在宿主机中看该进程PID还是原来的PID。

假设容器中进程真实PID=100，容器通过PID Namespace将其前面的99个进程隐藏起来了，这个PID=100的进程就认为自己是第一个进程即PID=1.

实际在宿主机中查看，该进程PID依旧是100.

除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。

比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。

**这，就是 Linux 容器最基本的实现原理了。**

在使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。

**虽然通过 Namespace  实现了隔离，但是隔离得还不够彻底。**

首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。

> 这样看来容器给应用暴露出来的攻击面是相当大的，应用“越狱”的难度自然也比虚拟机低得多。
>
> 进过可以通过 Seccomp 等技术对容器内部发起的系统调用进行过滤和甄别来进行安全加固，但这种方法因为多了一层对系统调用的过滤，必然会拖累容器的性能，而且也没人知道到底该允许或禁止哪些调用。
>
> 所以，在生产环境中，没有人敢把运行在物理机上的 Linux 容器直接暴露到公网上。

其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。

> 意味着某个容器修改了时间，会导致整个宿主机的时间都会随之修改，这显然不符合用户预期。

基于虚拟化或者独立内核技术的容器实现，则可以比较好地在隔离与性能之间做出平衡。

## 3.Cgroups

**Namespace 技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。**

由于是共享宿主机资源的，所以需要对各个容器能使用的资源进行限制。



**Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。**

Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。



**容器就是通过 Cgroups 来进行容器资源限制的。**



## 4. 生命周期

由于一个容器的本质就是一个进程，用户的应用进程实际上就是容器里 PID=1 的进程，也是其他后续创建的所有进程的父进程。

这就意味着，在一个容器中，你没办法同时运行两个不同的应用，除非你能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程，这也是为什么很多人都会用 systemd 或者 supervisord 这样的软件来代替应用本身作为容器的启动进程。



这是因为容器本身的设计，就是希望容器和应用能够**同生命周期**，这个概念对后续的容器编排非常重要。

**否则，一旦出现类似于“容器是正常运行的，但是里面的应用早已经挂了”的情况，编排系统处理起来就非常麻烦了。**

> 当然了，这个问题是有其他更好的解决方案的。