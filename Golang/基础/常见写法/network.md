# network

## 1. TCP/IP

### 问题1

**`net.Dial`函数的第一个参数`network`有哪些可选值？**

```go
	conn, e := net.Dial("tcp", "127.0.0.1:8888")
```



`net.Dial`函数会接受两个参数，分别名为`network`和`address`，都是`string`类型的。

参数`network`常用的可选值一共有 9 个。这些值分别代表了程序底层创建的 socket 实例可使用的不同通信协议，罗列如下。

- `"tcp"`：代表 TCP 协议，其基于的 IP 协议的版本根据参数`address`的值自适应。
- `"tcp4"`：代表基于 IP 协议第四版的 TCP 协议。
- `"tcp6"`：代表基于 IP 协议第六版的 TCP 协议。
- `"udp"`：代表 UDP 协议，其基于的 IP 协议的版本根据参数`address`的值自适应。
- `"udp4"`：代表基于 IP 协议第四版的 UDP 协议。
- `"udp6"`：代表基于 IP 协议第六版的 UDP 协议。
- `"unix"`：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_STREAM 为 socket 类型。
- `"unixgram"`：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_DGRAM 为 socket 类型。
- `"unixpacket"`：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_SEQPACKET 为 socket 类型。



### 问题2

**调用`net.DialTimeout`函数时给定的超时时间意味着什么？**

简单来说，这里的超时时间，代表着函数为网络连接建立完成而等待的最长时间。这是一个相对的时间。它会由这个函数的参数`timeout`的值表示。

开始的时间点几乎是我们调用`net.DialTimeout`函数的那一刻。在这之后，时间会主要花费在“解析参数`network`和`address`的值”，以及“创建 socket 实例并建立网络连接”这两件事情上。

不论执行到哪一步，只要在绝对的超时时间达到的那一刻，网络连接还没有建立完成，该函数就会返回一个代表了 I/O 操作超时的错误值。



## 2. http



### 问题1

**`http.Client`类型中的`Transport`字段代表着什么？**

`http.Client`类型中的`Transport`字段代表着：向网络服务发送 HTTP 请求，并从网络服务接收 HTTP 响应的操作过程。也就是说，该字段的方法`RoundTrip`应该实现单次 HTTP 事务（或者说基于 HTTP 协议的单次交互）需要的所有步骤。





### 问题2

**`http.Server`类型的`ListenAndServe`方法都做了哪些事情？**

这个`ListenAndServe`方法主要会做下面这几件事情。

* 1）检查当前的`http.Server`类型的值（以下简称当前值）的`Addr`字段。该字段的值代表了当前的网络服务需要使用的网络地址，即：IP 地址和端口号. 如果这个字段的值为空字符串，那么就用`":http"`代替。也就是说，使用任何可以代表本机的域名和 IP 地址，并且端口号为`80`。
* 2）通过调用`net.Listen`函数在已确定的网络地址上启动基于 TCP 协议的监听。
* 3）检查`net.Listen`函数返回的错误值。如果该错误值不为`nil`，那么就直接返回该值。否则，通过调用当前值的`Serve`方法准备接受和处理将要到来的 HTTP 请求。

可以从当前问题直接衍生出的问题一般有两个：

一个是“`net.Listen`函数都做了哪些事情”；

另一个是“`http.Server`类型的`Serve`方法是怎样接受和处理 HTTP 请求的”。

**对于第一个直接的衍生问题，如果概括地说，回答可以是：**

* 1）解析参数值中包含的网络地址隐含的 IP 地址和端口号；
* 2）根据给定的网络协议，确定监听的方法，并开始进行监听。

从这里的第二个步骤出发，我们还可以继续提出一些间接的衍生问题。这往往会涉及`net.socket`函数以及相关的 socket 知识。

在一个`for`循环中，网络监听器的`Accept`方法会被不断地调用，该方法会返回两个结果值；第一个结果值是`net.Conn`类型的，它会代表包含了新到来的 HTTP 请求的网络连接；第二个结果值是代表了可能发生的错误的`error`类型值。

如果这个错误值不为`nil`，除非它代表了一个暂时性的错误，否则循环都会被终止。如果是暂时性的错误，那么循环的下一次迭代将会在一段时间之后开始执行。

如果这里的`Accept`方法没有返回非`nil`的错误值，那么这里的程序将会先把它的第一个结果值包装成一个`*http.conn`类型的值（以下简称`conn`值），然后通过在新的 goroutine 中调用这个`conn`值的`serve`方法，来对当前的 HTTP 请求进行处理。