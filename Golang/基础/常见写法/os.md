# os 包中的 API



### 问题1

**`os.File`类型都实现了哪些`io`包中的接口？**

`os.File`类型拥有的都是指针方法，所以除了空接口之外，它本身没有实现任何接口。而它的指针类型则实现了很多`io`代码包中的接口。

首先，对于`io`包中最核心的 3 个简单接口`io.Reader`、`io.Writer`和`io.Closer`，`*os.File`类型都实现了它们。

其次，该类型还实现了另外的 3 个简单接口，即：`io.ReaderAt`、`io.Seeker`和`io.WriterAt`。

正是因为`*os.File`类型实现了这些简单接口，所以它也顺便实现了`io`包的 9 个扩展接口中的 7 个。然而，由于它并没有实现简单接口`io.ByteReader`和`io.RuneReader`，所以它没有实现分别作为这两者的扩展接口的`io.ByteScanner`和`io.RuneScanner`。

总之，`os.File`类型及其指针类型的值，不但可以通过各种方式读取和写入某个文件中的内容，还可以寻找并设定下一次读取或写入时的起始索引位置，另外还可以随时对文件进行关闭。

但是，它们并不能专门地读取文件中的下一个字节或者下一个 Unicode 字符，也不能进行任何的读回退操作。不过，单独读取下一个字节或字符的功能也可以通过其他方式来实现，比如，调用它的`Read`方法并传入适当的参数值就可以做到这一点。



```go
	os.OpenFile("t.txt", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)

```

最后，再说一下`os.OpenFile`函数。这个函数其实是`os.Create`函数和`os.Open`函数的底层支持，它最为灵活。

这个函数有 3 个参数，分别名为`name`、`flag`和`perm`。其中的`name`指代的就是文件的路径。而`flag`参数指的则是需要施加在文件描述符之上的模式，我在前面提到的只读模式就是这里的一个可选项。

在 Go 语言中，这个只读模式由常量`os.O_RDONLY`代表，它是`int`类型的。当然了，这里除了只读模式之外，还有几个别的模式可选，我们稍后再细说。

`os.OpenFile`函数的参数`perm`代表的也是模式，它的类型是`os.FileMode`，此类型是一个基于`uint32`类型的再定义类型。

为了加以区别，我们把参数`flag`指代的模式叫做操作模式，而把参数`perm`指代的模式叫做权限模式。可以这么说，前者限定了操作文件的方式，而后者则可以控制文件的访问权限。



### 小结

到这里，你需要记住的是，通过`os.File`类型的值，我们不但可以对文件进行读取、写入、关闭等操作，还可以设定下一次读取或写入时的起始索引位置。

此外，`os`包中还有用于创建全新文件的`Create`函数，用于包装现存文件的`NewFile`函数，以及可被用来打开已存在的文件的`Open`函数和`OpenFile`函数



### 问题2

**可应用于`File`值的操作模式都有哪些？**

针对`File`值的操作模式主要有只读模式、只写模式和读写模式。这些模式分别由常量`os.O_RDONLY`、`os.O_WRONLY`和`os.O_RDWR`代表。在我们新建或打开一个文件的时候，必须把这三个模式中的一个设定为此文件的操作模式。

除此之外，我们还可以为这里的文件设置额外的操作模式，可选项如下所示。

- `os.O_APPEND`：当向文件中写入内容时，把新内容追加到现有内容的后边。
- `os.O_CREATE`：当给定路径上的文件不存在时，创建一个新文件。
- `os.O_EXCL`：需要与`os.O_CREATE`一同使用，表示在给定的路径上不能有已存在的文件。
- `os.O_SYNC`：在打开的文件之上实施同步 I/O。它会保证读写的内容总会与硬盘上的数据保持同步。
- `os.O_TRUNC`：如果文件已存在，并且是常规的文件，那么就先清空其中已经存在的任何内容。

对于以上操作模式的使用，`os.Create`函数和`os.Open`函数都是现成的例子。

```go
func Create(name string) (*File, error) {
	return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
```

`os.Create`函数在调用`os.OpenFile`函数的时候，给予的操作模式是`os.O_RDWR`、`os.O_CREATE`和`os.O_TRUNC`的组合。

这就基本上决定了前者的行为，即：如果参数`name`代表路径之上的文件不存在，那么就新建一个，否则，先清空现存文件中的全部内容。并且，它返回的`File`值的读取方法和写入方法都是可用的。



### 问题3

**怎样设定常规文件的访问权限？**

我们已经知道，`os.OpenFile`函数的第三个参数`perm`代表的是权限模式，其类型是`os.FileMode`。但实际上，`os.FileMode`类型能够代表的，可远不只权限模式，它还可以代表文件模式（也可以称之为文件种类）。

由于`os.FileMode`是基于`uint32`类型的再定义类型，所以它的每个值都包含了 32 个比特位。在这 32 个比特位当中，每个比特位都有其特定的含义。

比如，如果在其最高比特位上的二进制数是`1`，那么该值表示的文件模式就等同于`os.ModeDir`，也就是说，相应的文件代表的是一个目录。

又比如，如果其中的第 26 个比特位上的是`1`，那么相应的值表示的文件模式就等同于`os.ModeNamedPipe`，也就是说，那个文件代表的是一个命名管道。

**实际上，在一个`os.FileMode`类型的值（以下简称`FileMode`值）中，只有最低的 9 个比特位才用于表示文件的权限。**当我们拿到一个此类型的值时，可以把它和`os.ModePerm`常量的值做按位与操作。

这个常量的值是`0777`，是一个八进制的无符号整数，其最低的 9 个比特位上都是`1`，而更高的 23 个比特位上都是`0`。

所以，经过这样的按位与操作之后，我们即可得到这个`FileMode`值中所有用于表示文件权限的比特位，也就是该值所表示的权限模式。这将会与我们调用`FileMode`值的`Perm`方法所得到的结果值是一致。

**在这 9 个用于表示文件权限的比特位中，每 3 个比特位为一组，共可分为 3 组**。从高到低，这 3 组分别表示的是`文件所有者`（也就是创建这个文件的那个用户）、`文件所有者所属的用户组`，以及`其他用户对该文件的访问权限`。而对于每个组，其中的 3 个比特位从高到低分别表示`读权限`、`写权限`和`执行权限`。

如果在其中的某个比特位上的是`1`，那么就意味着相应的权限开启，否则，就表示相应的权限关闭。

因此，八进制整数`0777`就表示：操作系统中的所有用户都对当前的文件有读、写和执行的权限，而八进制整数`0666`则表示：所有用户都对当前文件有读和写的权限，但都没有执行的权限。

我们在调用`os.OpenFile`函数的时候，可以根据以上说明设置它的第三个参数。**但要注意，只有在新建文件的时候，这里的第三个参数值才是有效的**。在其他情况下，即使我们设置了此参数，也不会对目标文件产生任何的影响。

