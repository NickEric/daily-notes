# String



## 1. string

### 问题1

**一个`string`类型的值在底层是怎样被表达的？**

在底层，一个`string`类型的值是由一系列相对应的 Unicode 代码点的 UTF-8 编码值来表达的。

**解析**

在 Go 语言中，一个`string`类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。前者可以由一个以`rune`为元素类型的切片来表示，而后者则可以由一个以`byte`为元素类型的切片代表。

`rune`是 Go 语言特有的一个基本数据类型，它的一个值就代表一个字符，即：一个 Unicode 字符。比如，`'G'`、`'o'`、`'爱'`、`'好'`、`'者'`代表的就都是一个 Unicode 字符。

我们已经知道，UTF-8 编码方案会把一个 Unicode 字符编码为一个长度在 [1, 4] 范围内的字节序列。所以，一个`rune`类型的值也可以由一个或多个字节来代表。

```
type rune = int32
```

根据`rune`类型的声明可知，它实际上就是`int32`类型的一个别名类型。也就是说，一个`rune`类型的值会由四个字节宽度的空间来存储。它的存储空间总是能够存下一个 UTF-8 编码值。

一个`rune`类型的值在底层其实就是一个 UTF-8 编码值。前者是（便于我们人类理解的）外部展现，后者是（便于计算机系统理解的）内在表达。

请看下面的代码：

```go
str := "Go爱好者"
fmt.Printf("The string: %q\n", str)
fmt.Printf("  => runes(char): %q\n", []rune(str))
fmt.Printf("  => runes(hex): %x\n", []rune(str))
fmt.Printf("  => bytes(hex): [% x]\n", []byte(str))
```

字符串值`"Go 爱好者"`如果被转换为`[]rune`类型的值的话，其中的每一个字符（不论是英文字符还是中文字符）就都会独立成为一个`rune`类型的元素值。因此，这段代码打印出的第二行内容就会如下所示：

```
  => runes(char): ['G' 'o' '爱' '好' '者']
```

又由于，每个`rune`类型的值在底层都是由一个 UTF-8 编码值来表达的，所以我们可以换一种方式来展现这个字符序列：

```
  => runes(hex): [47 6f 7231 597d 8005]
```

可以看到，五个十六进制数与五个字符相对应。很明显，前两个十六进制数`47`和`6f`代表的整数都比较小，它们分别表示字符`'G'`和`'o'`。因为它们都是英文字符，所以对应的 UTF-8 编码值用一个字节表达就足够了。一个字节的编码值被转换为整数之后，不会大到哪里去。

而后三个十六进制数`7231`、`597d`和`8005`都相对较大，它们分别表示中文字符`'爱'`、`'好'`和`'者'`。这些中文字符对应的 UTF-8 编码值，都需要使用三个字节来表达。所以，这三个数就是把对应的三个字节的编码值，转换为整数后得到的结果。

我们还可以进一步地拆分，把每个字符的 UTF-8 编码值都拆成相应的字节序列。上述代码中的第五行就是这么做的。它会得到如下的输出：

```
  => bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]
```

这里得到的字节切片比前面的字符切片明显长了很多。这正是因为一个中文字符的 UTF-8 编码值需要用三个字节来表达。这个字节切片的前两个元素值与字符切片的前两个元素值是一致的，而在这之后，前者的每三个元素值才对应字符切片中的一个元素值。

注意，对于一个多字节的 UTF-8 编码值来说，我们可以把它当做一个整体转换为单一的整数，也可以先把它拆成字节序列，再把每个字节分别转换为一个整数，从而得到多个整数。

这两种表示法展现出来的内容往往会很不一样。比如，对于中文字符`'爱'`来说，它的 UTF-8 编码值可以展现为单一的整数`7231`，也可以展现为三个整数，即：`e7`、`88`和`b1`。

总之，一个`string`类型的值会由若干个 Unicode 字符组成，每个 Unicode 字符都可以由一个`rune`类型的值来承载。

这些字符在底层都会被转换为 UTF-8 编码值，而这些 UTF-8 编码值又会以字节序列的形式表达和存储。**因此，一个`string`类型的值在底层就是一个能够表达若干个 UTF-8 编码值的字节序列**。



### 问题2

**使用带有`range`子句的`for`语句遍历字符串值的时候应该注意什么？**

带有`range`子句的`for`语句会先把被遍历的字符串值拆成一个字节序列，然后再试图找出这个字节序列中包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。

这样的`for`语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值就将会是当前字节序列中的某个 UTF-8 编码值的第一个字节所对应的那个索引值。而赋给第二个变量的值则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是`rune`。

例如，有这么几行代码：

```go
	str := "Go爱好者"
	for i, c := range str {
		fmt.Printf("%d: %q [% x]\n", i, c, []byte(string(c)))
	}
```

这里被遍历的字符串值是`"Go 爱好者"`。在每次迭代的时候，这段代码都会打印出两个迭代变量的值，以及第二个值的字节序列形式。完整的打印内容如下：

```
0: 'G' [47]
1: 'o' [6f]
2: '爱' [e7 88 b1]
5: '好' [e5 a5 bd]
8: '者' [e8 80 85]
```

第一行内容中的关键信息有`0`、`'G'`和`[47]`。这是由于这个字符串值中的第一个 Unicode 字符是`'G'`。该字符是一个单字节字符，并且由相应的字节序列中的第一个字节表达。这个字节的十六进制表示为`47`。

下面要注意了，正是因为`'爱'`是由三个字节共同表达的，所以第四个 Unicode 字符`'好'`对应的索引值并不是`3`，而是`2`加`3`后得到的`5`。

这里的`2`代表的是`'爱'`对应的索引值，而`3`代表的则是`'爱'`对应的 UTF-8 编码值的宽度。对于这个字符串值中的最后一个字符`'者'`来说也是类似的，因此，它对应的索引值是`8`。

由此可以看出，这样的`for`语句可以逐一地迭代出字符串值里的每个 Unicode 字符。但是，相邻的 Unicode 字符的索引值并不一定是连续的。这取决于前一个 Unicode 字符是否为单字节字符。

正因为如此，如果我们想得到其中某个 Unicode 字符对应的 UTF-8 编码值的宽度，就可以用下一个字符的索引值减去当前字符的索引值。

### 小结

**Go 语言的代码是由 Unicode 字符组成的**，它们都必须由 `Unicode` 编码规范中的 `UTF-8` 编码格式进行编码并存储，否则就会导致 go 命令的报错。

Unicode 编码规范中的编码格式定义的是`字符`与`字节序列`之间的转换方式。

其中的 UTF-8 是一种可变宽的编码方案。它会用一个或多个字节的二进制数来表示某个字符，最多使用`四个字节`。一个受支持的字符总是可以由 UTF-8 编码为一个字节序列，后者也可以被称为 UTF-8 编码值。

Go 语言中的一个`string`类型值会由若干个 Unicode 字符组成，每个 Unicode 字符都可以由一个`rune`类型的值来承载。这些字符在底层都会被转换为 UTF-8 编码值，而这些 UTF-8 编码值又会以`字节序列`的形式表达和存储。

**因此，一个`string`类型的值在底层就是一个能够表达若干个 UTF-8 编码值的字节序列。**



这样的`for range`语句会先把被遍历的字符串值拆成一个`字节序列`，然后再试图找出这个字节序列中包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。相邻的 Unicode 字符的索引值并不一定是连续的。这取决于前一个 Unicode 字符是否为单字节字符。一旦我们清楚了这些内在机制就不会再困惑了。



## 2. strings.Builder

### 问题1

**与`string`值相比，`strings.Builder`类型的值有哪些优势？**

`strings.Builder`类型的值（以下简称`Builder`值）的优势有下面的三种：

* 1) 已存在的内容不可变，但可以拼接更多的内容；
* 2) 减少了内存分配和内容拷贝的次数；
* 3) 可将内容重置，可重用值。



**解析**

在 Go 语言中，`string`类型的值是不可变的。我们在进行字符串拼接的时候，Go 语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，并把持有相应指针值的`string`值作为结果返回。

`Builder`值中有一个用于承载内容的容器，它是一个以`byte`为元素类型的切片。通过拼接方法把新的内容拼接到已存在的内容的尾部。



### 问题2

**`strings.Builder`类型在使用上有约束吗？**

有约束，概括如下：

* 1）在已被真正使用后就不可再被复制；
* 2）由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题。



### 问题3

**为什么说`strings.Reader`类型的值可以高效地读取字符串？**

与`strings.Builder`类型恰恰相反，`strings.Reader`类型是为了高效读取字符串而存在的。后者的高效主要体现在它对字符串的读取机制上，它封装了很多用于在`string`值上读取内容的最佳实践。

`strings.Reader`类型的值（以下简称`Reader`值）可以让我们很方便地读取一个字符串中的内容。在读取的过程中，`Reader`值会保存已读取的字节的计数（以下简称已读计数）。

已读计数也代表着下一次读取的起始索引位置。`Reader`值正是依靠这样一个计数，以及针对字符串值的切片表达式，从而实现快速读取。



### 小结

* 1） string拼接的结果是生成新的string，需要把原字符串拷贝到新的string中；Builder底层有个[]byte,按需扩容，不必每次拼接都需要拷贝；
* 2）Reader的优势是维护一个已读计数器，知道下一次读的位置，读得更快。



