# 错误处理

## 1. error

**对于具体错误的判断，Go 语言中都有哪些惯用法？**

由于`error`是一个接口类型，所以即使同为`error`类型的错误值，它们的实际类型也可能不同。这个问题还可以换一种问法，即：怎样判断一个错误值具体代表的是哪一类错误？

这道题的**典型回答**是这样的：

* 1）对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型`switch`语句来判断；
* 2）对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断；
* 3）对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。



## 2. panic

如下程序很明显会出现 panic。

```go
func panicA() {
	arr := []int{1, 2, 3, 4, 5}
	fmt.Println(arr[5])
}
```



```shell
panic: runtime error: index out of range [5] with length 5

goroutine 1 [running]:
main.main() 
	panic.go:6 +0x1b
Process finished with exit code 2
```

其中的“runtime error”表示这是一个`runtime`代码包中抛出的 panic。

`index out of range [5] with length 5` 正是这个 panic 包含的`runtime.Error`类型值的字符串表示形式。

此外，panic 详情中一般还会包含与它的引发原因有关的 goroutine 的代码执行信息。正如前述详情中的“goroutine 1 [running]”，它表示有一个 ID 为`1`的 goroutine 在此 panic 被引发的时候正在运行。

> 注意，这里的 ID 其实并不重要，因为它只是 Go 语言运行时系统内部给予的一个 goroutine 编号，我们在程序中是无法获取和更改的。

我们再看下一行，“main.main()”表明了这个 goroutine 包装的`go`函数就是命令源码文件中的那个`main`函数，也就是说这里的 goroutine 正是主 goroutine。再下面的一行，指出的就是这个 goroutine 中的哪一行代码在此 panic 被引发时正在执行。

这一行最后的`+0x1b`代表的是：此行代码相对于其所属函数的入口程序计数偏移量。不过，一般情况下它的用处并不大。

最后，“Process finished with exit code 2”表明我的这个程序是以退出状态码`2`结束运行的。

> 在大多数操作系统中，只要退出状态码不是`0`，都意味着程序运行的非正常结束。在 Go 语言中，因 panic 导致程序结束运行的退出状态码一般都会是`2`。

### 问题1

**从 panic 被引发到程序终止运行的大致过程是什么？**

> 触发 panic 后初始 panic 会被建立，程序控制权一层一层向上转移(调用栈反方向传递)，一般最后会到最外层的 main 函数，这个过程中 panic 详情会逐渐积累并完善。最终控制权被 Go 语言运行时系统收回，程序崩溃并打印出完整 panic 详情。

我们先说一个大致的过程:

某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。

这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。

这里的最外层函数指的是`go`函数，对于主 goroutine 来说就是`main`函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。

随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。

### 问题2

**怎样让 panic 包含一个值，以及应该让它包含什么样的值？**

这其实很简单，在调用`panic`函数时，把某个值作为参数传给该函数就可以了。由于`panic`函数的唯一一个参数是空接口（也就是`interface{}`）类型的，所以从语法上讲，它可以接受任何类型的值。

但是，我们最好传入`error`类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示形式转换。

## 3. recover

**怎样施加应对 panic 的保护措施，从而避免程序崩溃？**

Go 语言的内建函数`recover`专用于恢复 panic，或者说平息运行时恐慌。`recover`函数无需任何参数，并且会返回一个空接口类型的值。

如果用法正确，这个值实际上就是即将恢复的 panic 包含的值。并且，如果这个 panic 是因我们调用`panic`函数而引发的，那么该值同时也会是我们此次调用`panic`函数时，传入的参数值副本。请注意，这里强调用法的正确。我们先来看看什么是不正确的用法。

```go
func panicB() {
	fmt.Println("Enter function main.")
	// 引发 panic。
	panic(errors.New("something wrong"))
	p := recover()
	fmt.Printf("panic: %s\n", p)
	fmt.Println("Exit function main.")
}
```

panic 触发后会向反方向传递。所以后面的代码根本没有机会执行，recover 自然也就没用了。

如果放在前面呢? 显然也没有意义，如果在我们调用`recover`函数时未发生 panic，那么该函数就不会做任何事情，并且只会返回一个`nil`。



**正确做法是使用 defer **

无论函数结束执行的原因是什么，其中的`defer`函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一个 panic 也会是这样。



## 4. defer

**如果一个函数中有多条`defer`语句，那么那几个`defer`函数调用的执行顺序是怎样的？**

如果只用一句话回答的话，那就是：

在同一个函数中，`defer`函数调用的执行顺序与它们分别所属的`defer`语句的出现顺序（更严谨地说，是执行顺序）完全相反。

在`defer`语句每次执行的时候，Go 语言会把它携带的`defer`函数及其参数值另行存储到一个队列中。

这个队列与该`defer`语句所属的函数是对应的，并且，它是**先进后出（FILO）**的，相当于一个栈。

在需要执行某个函数中的`defer`函数调用的时候，Go 语言会先拿到对应的队列，然后从该队列中一个一个地取出`defer`函数及其参数值，并逐个执行调用。

这正是我说“`defer`函数调用与其所属的`defer`语句的执行顺序完全相反”的原因了。