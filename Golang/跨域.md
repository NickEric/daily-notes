# 跨域

## 1. 什么是跨域

跨域指的是浏览器不能执行其他网站或域名下的脚本。之所以形成跨域，是因为浏览器的同源策略造成的，是浏览器对javascript程序做的安全限制，现在所有支持JavaScript 的浏览器都会使用这个策略。

在实际应用中会遇到需要跨域的场景，比如前后端分离，前后端不在同域（这里的同域指的是同一协议，同一域名，同一端口）。



## 2. 解决办法

大概有三类解决方案：

* 1）绕过同源策略
* 2）把跨域转为同域
* 3）服务端允许跨域 cors（跨域资源共享）

### 1. 绕过同源策略

jsonp 就是其中的一种。

jsonp跨域其实是利用iframe、img、srcipt，link标签的src或href属性来实现的，这些标签都可以发送一个get请求资源，src 和href 并没有受同源策略的限制。

jsonp主要站在前端的角度去解决问题，这种方式有一定的局限性，就是仅适用get请求。



### 2. 把跨域转为同域

其中一种就是 nginx 反向代理

nginx服务器作为中间代理（或跳转机），实现从域名A访问域名B，像访问同域一样。

例如

```shell
server {
           listen 80;
           server_name http://domain1; 

           location / {
               proxy_pass http://domain2:8081/;
               proxy_set_header Host $host;
               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
               proxy_set_header X-Forwarded-Proto $scheme;
               proxy_set_header X-Forwarded-Port $server_port;
            }
}
```



### 3. 服务端允许跨域 cors（跨域资源共享）

跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。

比如，站点 [http://domain-a.com](http://domain-a.com/) 的某 HTML 页面通过 的 src 请求 http://domain-b.com/image.jpg。 网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。

出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。

比如 gin 框架，跨域中间件

```go
package main

import (
    "github.com/gin-gonic/gin""net/http"
)


funcmain() {
    r := gin.Default()
    r.Use(Cors())//默认跨域
    r.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{
            "message": "pong",
        })
    })
    r.Run(":8090")
}
funcCors() gin.HandlerFunc {

    returnfunc(c *gin.Context) {
        method := c.Request.Method
        origin := c.Request.Header.Get("Origin")
        if origin != "" {
            c.Header("Access-Control-Allow-Origin", "*")
            c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
            c.Header("Access-Control-Allow-Headers", "Content-Type,AccessToken,X-CSRF-Token, Authorization")
            c.Header("Access-Control-Allow-Credentials", "true")
            c.Set("content-type", "application/json")
        }
        //放行所有OPTIONS方法if method == "OPTIONS" {
            c.AbortWithStatus(http.StatusNoContent)
        }
        c.Next()
    }
}
```

