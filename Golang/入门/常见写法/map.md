## Map相关写法

## 1. 概述

Go 语言的`字典`类型其实是一个`哈希表（hash table）`的特定实现。

`键`和`元素`的这种对应关系在数学里就被称为`映射`，这也是`map`这个词的本意。

> 哈希表的映射过程就存在于对键 - 元素对的增、删、改、查的操作之中。

比如我们要在哈希表中查找与某个键值对应的那个元素值，那么我们需要先把键值作为参数传给这个哈希表。哈希表会先用`哈希函数（hash function）`把键值转换为哈希值。

哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），也可称之为哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的那些键 - 元素对。

因此，哈希表会**先用这个键的哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键**。由于键 - 元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。

## 2. 规范

### 1.自动扩容

`map`在容量不足时会自动扩容，这里会有较大的消耗，所以如果一开始就能确定`map`的大小就可以在`make`时指定大小，从而省去扩容的这部分开销。

```go
myMap:=make(map[interface{}]interface{},len(xxxx))
```

### 2. 线程安全

Map是非线程安全的，使用时需要加锁以达到多线程安全的效果。

推荐使用读写锁以提升性能。



## 3. 问题

### 1. 为什么键必须支持判等操作？

> Go 语言规范规定，在键类型的值之间必须可以施加操作符`==`和`!=`。



如果有相等的，那就再用键值本身去对比一次。为什么还要对比？原因是，不同值的哈希值是可能相同的。这有个术语，叫做`哈希碰撞`。

所以，即使哈希值一样，键值也不一定一样。如果键类型的值之间无法判断相等，那么此时这个映射的过程就没办法继续下去了。最后，只有键的哈希值和键值都相等，才能说明查找到了匹配的键 - 元素对。

**由于会出现`哈希碰撞`的情况，所以 Go 语言在判断 hash 相同后还会判断键是否相同。**

> 如果键不支持判等操作 这步就没法进行了。



### 2. 应该优先考虑哪些类型作为字典的键类型？

在前文所述的映射过程中，“把键值转换为哈希值”以及“把要查找的键值与哈希桶中的键值做对比”， 明显是两个重要且比较耗时的操作。

因此，可以说，**求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。**



### 3. map 指针

我们都知道，字典中总会有若干个哈希桶用于均匀地储存键 - 元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并适时地把其中的键 - 元素对搬运到对应的新的哈希桶中。

在这种情况下，**获取字典中任何元素值的指针都是无意义的，也是不安全的**。我们不知道什么时候那个元素值会被搬运到何处，也不知道原先的那个内存地址上还会被存放什么别的东西。所以，这样的值就应该是不可寻址的。