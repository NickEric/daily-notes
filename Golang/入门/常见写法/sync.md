# sync

## 1. Mutex

Go 语言中的互斥锁是开箱即用的,换句话说，一旦我们声明了一个`sync.Mutex`类型的变量，就可以直接使用它了。

```go
var m sync.Mutex
m.Lock()
m.Unlock()
```

下面这种写法是**不推荐**的:

```go
var m=new(sync.Mutex)
```

因为 Mutex 中 state 为 0 表示未锁定 1 为锁定，int32 类型零值刚好为 0，即未锁定状态。

```go
type Mutex struct {
	state int32
	sema  uint32
}
const (
	mutexLocked = 1 << iota // mutex is locked
)
```





### 问题1

**我们使用互斥锁时有哪些注意事项？**

使用互斥锁的注意事项如下：

* 1）不要重复锁定互斥锁；

* 2）不要忘记解锁互斥锁，必要时使用`defer`语句；

* 3）不要对尚未锁定或者已解锁的互斥锁解锁；

* 4）不要在多个函数之间直接传递互斥锁。

**我们总是应该保证，对于每一个锁定操作，都要有且只有一个对应的解锁操作。**



### 问题2

**读写锁与互斥锁有哪些异同？**

顾名思义，读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护。换句话说，相比于互斥锁，读写锁可以实现**更加细腻的访问控制**。

**读写锁中读操作和写操作时互斥的，但多个读操作却不会互斥。**



## 2. Cond



### 问题1

**条件变量怎样与互斥锁配合使用？**

条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。

条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。我们在利用条件变量等待通知的时候，需要在它基于的那个互斥锁
保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后再做这两种操作。



### 问题2

**`cond`的`Wait`方法做了什么？**

* 1) 把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中。
* 2) 解锁当前的条件变量基于的那个互斥锁。
* 3) 让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这个`Wait`方法的那行代码上。
* 4) 如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的 goroutine 就会继续执行后面的代码了。



### 问题3

**`cond`的`Signal`方法和`Broadcast`方法有哪些异同？**

`cond`的`Signal`方法和`Broadcast`方法都是被用来发送通知的，不同的是，前者的通知只会唤醒**一个**因此而等待的 goroutine，而后者的通知却会唤醒**所有**为此等待的 goroutine。

> `cond`的`Wait`方法总会把当前的 goroutine 添加到通知队列的队尾，而它的`Signal`方法总会从通知队列的**队首**开始查找可被唤醒的 goroutine。所以，因`Signal`方法的通知而被唤醒的 goroutine 一般都是**最早等待**的那一个。



## 3. WaitGroup

### 问题1

**`sync.WaitGroup`类型值中计数器的值可以小于`0`吗？**

不可以。**之所以说`WaitGroup`值中计数器的值不能小于`0`，是因为这样会引发一个 panic。** 

### 规范

最好用**先统一`Add`，再并发`Done`，最后`Wait`**这种标准方式，来使用`WaitGroup`值。

尤其不要在调用`Wait`方法的同时，并发地通过调用`Add`方法去增加其计数器的值，因为这也有可能引发 panic。

## 4. Once

### 问题1

**`sync.Once`类型值的`Do`方法是怎么保证只执行参数函数一次的？**

`Once`类型的`Do`方法只接受一个参数，这个参数的类型必须是`func()`，即：无参数声明和结果声明的函数。该方法的功能并不是对每一种参数函数都只执行一次，而是只执行**首次被调用时传入的**那个函数，并且之后不会再执行任何参数函数。

`Once`类型中还有一个名叫`done`的`uint32`类型的字段。它的作用是记录其所属值的`Do`方法被调用的次数。不过，该字段的值只可能是`0`或者`1`。一旦`Do`方法的首次调用完成，它的值就会从`0`变为`1`。

**你可能会问，既然`done`字段的值不是`0`就是`1`，那为什么还要使用需要四个字节的`uint32`类型呢？**

原因很简单，因为对它的操作必须是**原子**的。`Do`方法在一开始就会通过调用`atomic.LoadUint32`函数来获取该字段的值，并且一旦发现该值为`1`就会直接返回。这也初步保证了“`Do`方法，只会执行首次被调用时传入的函数”。

不过，单凭这样一个判断的保证是不够的。因为，如果有两个 goroutine 都调用了同一个新的`Once`值的`Do`方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为`false`而继续执行`Do`方法中剩余的代码。

在这个条件判断之后，`Do`方法会立即锁定其所属值中的那个`sync.Mutex`类型的字段`m`。然后，它会在临界区中再次检查`done`字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把`done`的值变为`1`。

如果你熟悉 GoF 设计模式中的单例模式的话，那么肯定能看出来，这个`Do`方法的实现方式，与那个**单例模式(double check)**有很多相似之处。

它们都会先在临界区之外判断一次关键条件，若条件不满足则立即返回

> 这通常被称为“快路径”，或者叫做“快速失败路径”。

如果条件满足，那么到了临界区中还要再对关键条件进行一次判断，这主要是为了更加严谨。

这两次条件判断常被统称为（跨临界区的）“双重检查”。

> 由于进入临界区之前，肯定要锁定保护它的互斥锁`m`，显然会降低代码的执行速度，所以其中的第二次条件判断，以及后续的操作就被称为“慢路径”或者“常规路径”。

### 两个特点



**第一个特点**，由于`Do`方法只会在参数函数**执行结束之后**把`done`字段的值变为`1`，因此，如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关 goroutine 的同时阻塞。

例如，有多个 goroutine 并发地调用了同一个`Once`值的`Do`方法，并且传入的函数都会一直执行而不结束。那么，这些 goroutine 就都会因调用了这个`Do`方法而阻塞。因为，除了那个抢先执行了参数函数的 goroutine 之外，其他的 goroutine 都会被阻塞在锁定该`Once`值的互斥锁`m`的那行代码上。

**第二个特点**，`Do`方法在参数函数执行结束后，对`done`字段的赋值用的是**原子操作**，并且，这一操作是被挂在`defer`语句中的。因此，不论参数函数的执行会以怎样的方式结束，`done`字段的值都会变为`1`。

也就是说，即使这个参数函数没有执行成功（比如引发了一个 panic），我们也无法使用同一个`Once`值重新执行它了。所以，如果你需要为参数函数的执行设定重试机制，那么就要考虑`Once`值的适时替换问题。

在很多时候，我们需要依据`Do`方法的这两个特点来设计与之相关的流程，以避免不必要的程序阻塞和功能缺失。



## 5. Pool



### 问题1

**为什么说临时对象池中的值会被及时地清理掉？**

因为，Go 语言运行时系统中的垃圾回收器，在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除。

`ync`包在被初始化的时候，会向 Go 语言运行时系统注册一个函数，这个函数的功能就是清除所有已创建的临时对象池中的值。我们可以把它称为池清理函数。一旦池清理函数被注册到了 Go 语言运行时系统，后者在每次即将执行垃圾回收时就都会执行前者。

另外，在`sync`包中还有一个包级私有的全局变量。这个变量代表了当前的程序中使用的所有临时对象池的汇总，它是元素类型为`*sync.Pool`的切片。我们可以称之为池汇总列表。

通常，在一个临时对象池的`Put`方法或`Get`方法第一次被调用的时候，这个池就会被添加到池汇总列表中。正因为如此，池清理函数总是能访问到所有正在被真正使用的临时对象池。

更具体地说，池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为`nil`，然后再把这个池中的所有本地池列表都销毁掉。

最后，池清理函数会把池汇总列表重置为空的切片。如此一来，这些池中存储的临时对象就全部被清除干净了。如果临时对象池以外的代码再无对它们的引用，那么在稍后的垃圾回收过程中，这些临时对象就会被当作垃圾销毁掉，它们占用的内存空间也会被回收以备他用。

### 问题2

**临时对象池存储值所用的数据结构是怎样的？**

在临时对象池中，有一个多层的数据结构。正因为有了它的存在，临时对象池才能够非常高效地存储大量的值。

这个数据结构的顶层，我们可以称之为本地池列表，不过更确切地说，它是一个数组。这个列表的长度，总是与 Go 语言调度器中的 P 的数量相同。

还记得吗？Go 语言调度器中的 P 是 processor 的缩写，它指的是一种可以承载若干个 G、且能够使这些 G 适时地与 M 进行对接，并得到真正运行的中介。

这里的 G 正是 goroutine 的缩写，而 M 则是 machine 的缩写，后者指代的是系统级的线程。正因为有了 P 的存在，G 和 M 才能够进行灵活、高效的配对，从而实现强大的并发编程模型。

P 存在的一个很重要的原因是为了分散并发程序的执行压力，而让临时对象池中的本地池列表的长度与 P 的数量相同的主要原因也是分散压力。这里所说的压力包括了存储和性能两个方面。在说明它们之前，我们先来探索一下临时对象池中的那个数据结构。

在本地池列表中的每个本地池都包含了三个字段（或者说组件），它们是：存储私有临时对象的字段`private`、代表了共享临时对象列表的字段`shared`，以及一个`sync.Mutex`类型的嵌入字段。

实际上，每个本地池都对应着一个 P。我们都知道，一个 goroutine 要想真正运行就必须先与某个 P 产生关联。也就是说，一个正在运行的 goroutine 必然会关联着某个 P。

在程序调用临时对象池的`Put`方法或`Get`方法的时候，总会先试图从该临时对象池的本地池列表中，获取与之对应的本地池，依据的就是与当前的 goroutine 关联的那个 P 的 ID。

换句话说，一个临时对象池的`Put`方法或`Get`方法会获取到哪一个本地池，完全取决于调用它的代码所在的 goroutine 关联的那个 P。



### 问题3

**临时对象池是怎样利用内部数据结构来存取值的？**

临时对象池的`Put`方法总会先试图把新的临时对象，存储到对应的本地池的`private`字段中，以便在后面获取临时对象的时候，可以快速地拿到一个可用的值。只有当这个`private`字段已经存有某个值时，该方法才会去访问本地池的`shared`字段。

相应的，临时对象池的`Get`方法，总会先试图从对应的本地池的`private`字段处获取一个临时对象。只有当这个`private`字段的值为`nil`时，它才会去访问本地池的`shared`字段。

一个本地池的`shared`字段原则上可以被任何 goroutine 中的代码访问到，不论这个 goroutine 关联的是哪一个 P。这也是我把它叫做共享临时对象列表的原因。相比之下，一个本地池的`private`字段，只可能被与之对应的那个 P 所关联的 goroutine 中的代码访问到，所以可以说，它是 P 级私有的。

以临时对象池的`Put`方法为例，它一旦发现对应的本地池的`private`字段已存有值，就会去访问这个本地池的`shared`字段。当然，由于`shared`字段是共享的，所以此时必须受到互斥锁的保护。

还记得本地池嵌入的那个`sync.Mutex`类型的字段吗？它就是这里用到的互斥锁，也就是说，本地池本身就拥有互斥锁的功能。`Put`方法会在互斥锁的保护下，把新的临时对象追加到共享临时对象列表的末尾。

相应的，临时对象池的`Get`方法在发现对应本地池的`private`字段未存有值时，也会去访问后者的`shared`字段。它会在互斥锁的保护下，试图把该共享临时对象列表中的最后一个元素值取出并作为结果。

不过，这里的共享临时对象列表也可能是空的，这可能是由于这个本地池中的所有临时对象都已经被取走了，也可能是当前的临时对象池刚被清理过。

无论原因是什么，`Get`方法都会去访问当前的临时对象池中的所有本地池，它会去逐个搜索它们的共享临时对象列表。

只要发现某个共享临时对象列表中包含元素值，它就会把该列表的最后一个元素值取出并作为结果返回。

当然了，即使这样也可能无法拿到一个可用的临时对象，比如，在所有的临时对象池都刚被大清洗的情况下就会是如此。

这时，`Get`方法就会使出最后的手段——调用可创建临时对象的那个函数。还记得吗？这个函数是由临时对象池的`New`字段代表的，并且需要我们在初始化临时对象池的时候给定。如果这个字段的值是`nil`，那么`Get`方法此时也只能返回`nil`了。