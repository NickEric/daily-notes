# 面向错误和恢复的设计

## 1. 面向错误的设计

### 1. 隔离

* 设计上

例如 微内核 模式。

将 plugin 与 内核分隔开，这样 plugin 出现异常也不会影响到整体

* 部署上

微服务部署，单个服务挂掉后，也可以通过服务降级等策略保证其他依赖该服务的服务可用。

### 2. 重用

服务 B 依赖 A

服务 C 也依赖 A 

代码编写时，很明显只需要写一遍 A 即可。

但是部署的时候要为 B 和 C 各种单独的部署一个 A，而不能重用。

### 3. 单点失效

假设当前请求压力 QPS 1500，单台服务器最大 QPS 1000

这个时候一般会想到，部分两台服务并通过负载均衡分发就能满足条件了。

实际情况却是，如果这两台中有任意一台挂掉了，另外一台也会因为压力过大一并挂掉。

### 4. 限流

一般采用 tokenBucket 的方式进行限流。

### 5. 等待超时

给所有阻塞操作都加上一个超时，不能无休止的等待。否则可能出现所有请求都阻塞在某一环节的情况。

### 6. 阻止错误传递-断路器

阻止错误传递，一般配合服务熔断、降级来实现。

多次访问同一个服务都请求失败后，在后续请求时直接返回失败，直到后续依赖服务恢复。



## 2. 面向恢复的设计

很明显我们是不能考虑到所有的错误情况的，所以对一些未知的错误需要有一定的恢复能力。



### 1. 监控检查

* 注意僵尸进程
* 池化资源耗尽
* 死锁



### 2. Let is Crash

```go
defer func() {
    if err := recover(); err != nil {
        logrus.Error(err)
    }
}()
```

避免在任何地方都这样写，虽然看似把错误 recover 了，程序还能继续运行。

但是如果遇到某些情况，可能会出现不可预知的问题。

> 比如某个资源耗尽了，就必然会出现这个问题，这样 recover 后，虽然看起来程序没问题，实际上已经无法正常提供服务了。

所以 Let is Crash！然后再由守护进程把 应用进程拉起来。



### 3. 构建可恢复的系统

* 拒绝单体系统
* 面向错误和恢复得设计
  * 在依赖服务不可用时，应用本身依旧可以存活 -- 服务降级
  * 快速启动 -- 出现问题后能快速重新启动新的实例
  * 无状态-- 有状态的应用在替换时会比较麻烦，替换后所有状态都重置了
* 与客户端协商
  * 服务器压力太，处理过不来时，告知客户端过段时间在请求