# Schema 与数据类型优化

## 1. 选择优化的数据类型

* 1）更小的通常更好

  *  一般选择一个不会超出范围的最小类型

* 2）简单就好

  * 简单数据类型的操作通常需要更少的 CPU 周期

* 3）尽量避免 NULL

  * 如果查询中包含可为 NULL 的列，对 MySQL 来说更难优化
  * 如果计划在列上建立索引，那么就应该避免设计成可为 NULL 的列

  

选型步骤

* 1）确定大类型，如数字、字符串、时间等
* 2）选择具体类型
  * DATATIME 和 TIMESAMP 都可以存储时间和日期，精确到秒。然而 TIMESAMP 只使用 DATATIME 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另一方面 TIMESAMP 允许的时间范围要小得多，有时候它的特殊能力会成为障碍。





### 整数类型

| 类型         | 大小                                     | 范围（有符号）                                               |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- |
| TINYINT      | 8位                                      | (-128，127)                                                  |
| SMALLINT     | 16位                                     | (-32 768，32 767)                                            |
| MEDIUMINT    | 24位                                     | (-8 388 608，8 388 607)                                      |
| INT或INTEGER | 32位                                     | (-2 147 483 648，2 147 483 647)                              |
| BIGINT       | 64位                                     | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      |
| FLOAT        | 32位                                     | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) |
| DOUBLE       | 64位                                     | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               |

范围都是在`（ -2^N-1~2^N-1）`，同时整数类型还有可选的 `UNSIGNED` 属性，不允许负值，这大致可以使得正数范围提高一倍。

### 实数类型

实数是带有小数部分的数字。

| 类型    | 大小                                     | 范围（有符号）                                               |
| :------ | :--------------------------------------- | :----------------------------------------------------------- |
| FLOAT   | 32位                                     | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) |
| DOUBLE  | 64位                                     | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |
| DECIMAL | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               |



### 字符串类型

CHAR 和 VARCHAR 是两种最主要的字符串类型。

* 1）VARCHAR

  * 用于存储可变长字符串，只需要使用额外1或 2 个额外字节记录字符串的长度。
  * 比较适合存储平均长度和最大长度差距很大的数据

* 2）CHAR

  * CHAR 类型是定长的，MySQL 总是根据定义的长度分配足够的空间。
  * 适合存储很短的字符串，或者所有值都接近同一个长度。

* 3）BLOB

  * BLOB是个类型系列，共包括四种BLOB类型：TinyBlob、Blob、MediumBlob、LongBlob，这几个类型之间的唯一区别是在存储文件的最大尺寸不同。

* 4）TEXT

  * TEXT与BLOB类似，但是TEXT是存储字符非二进制数据串，BLOB是存储字节的二进制串。

    TEXT也是个类型系列，共包括四种TEXT类型：TINYTEXT, TEXT, MEDIUMTEXT,LONGTEXT。





| 类型       | 大小                  | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |

**注意**：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。

BLOB 和 TEXT 值太大时， InnoDB 会使用专门的 外部存储区域进行存储，此时每个值在行内需要 1~4 个字节存储一个指针即可。

### 日期和时间类型



表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。

每个时间类型有一个有效值范围和一个"零"值，当指定不合法的MySQL不能表示的值时使用"零"值。

TIMESTAMP类型有专有的自动更新特性，将在后面描述。

**通常建议使用 TIMESTAMP。**

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |



## 2. schema 设计陷阱

* 1）太多的列
  * MySQL的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器将缓冲内容解码成各个列，**从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的**。
* 2）太多的关联
  * 一个粗略的经验法则：如果希望查询执行得快速且并发性好，单个查询最好在 12 个表以内做关联。
* 3）全能的枚举
  * 注意防止过度使用枚举（ENUM）
  * 例如 ENUM('1','2','3',...'31') 
* 4）凌乱的 SET
  * SET 中的值可以出现一个或多个
  * 例如 set('Y','N') 这样就会很奇怪
* 5）NULL
  * 即使需要存储一个`空值`到数据库中，也不一定是 NULL，也可以是 0，或其他特殊值等
  * 但是也不能太极端 当确实需要表示未知值时要不要害怕使用 NULL 
  * 比如`dt DATATIME NOT NULL DEFAULT '0000-00-00 00:00:00'` 这样伪造的全 0 值可能会导致很多问题

> MySQL 会在索引中存储 NULL 值，而 Oracle 则不会。



## 3. 范式与反范式

* 1）在范式化数据库中，每个事实数据会出现并且只出现一次。
  * 所以范式化数据库很少会出现重复数据，数据量会更小，更新操作也会更快。
  * 缺点就是通常需要关联，稍微复杂一点的查询语句可能都需要多次关联。
* 2）反范式化数据库则会存在部分冗余数据。
  * 数据量可能会大一些，更新操作会稍慢。
  * 但是由于存在冗余数据，所以大部分查询都不需要关联。



**一般实际中都是范式与反范式混用。**

> 比如在 order 表中如果只存 userId，那么每次查询肯定需要关联  user 表来查询 userName。
>
> 如果 order 表中冗余一个 userName 字段则可以避免该关联。
>
> 然后如果 用户频繁修改 userName 则会增加额外的工作。所以需要根据业务需求来选择合适的方案。



## 4. Schema 设计原则

MySQL 中使用的简单原则。

* 1）**尽量避免过度设计**

  * 例如会导致极其复杂查询的 schema
  * 或者有很多列的表设计

* 2）**使用小而简单的合适数据类型**

  * 除非真实数据模型中有确切的需要，否则应该竟可能地避免使用 NULL 值

* 3）**尽量使用相同的数据类型存储相似或相关的值**，尤其是要在关联条件中使用的列

  * 否则 MySQL 会自动进行类型转换，降低效率

* 4）**注意可变长字符串**

  * 在临时表和排序时可能导致悲观的按最大长度分配内存

* 5）**尽量使用整型定义标识列**

* 6）**避免使用 MySQL 已经遗弃的特性**

  * 例如指定浮点数的精度
  * 或者整数的显示宽度

  7）**小心使用 ENUM 和 SET，最好避免使用 BIT**