# 创建高性能索引

## 1. 概述

**索引**（在 MySQL 中也叫做`键(key)`）是存储引擎用于快速找到记录的一种**数据结构**。

### 哈希索引

例如需要存储大量的 URL，并需要根据 URL 进行搜索查找。如果使用 B-Tree 来存储，那么存储的内容就会很大，以为 URL 本身都很长。

正常情况下会有如下查询：

```mysql
SELECT id FROM url WHERE url = 'https://www.lixueduan.com';
```

若删除原来 URL 列上的索引，并新增一个被索引的 url_crc 列，使用 CRC32 做哈希就可以使用下面的方式查询：

```mysql
SELECT id FROM url WHERE url = 'https://www.lixueduan.com' AND url_crc = CRC32('https://www.lixueduan.com');
```

这样性能会非常高，因为 MySQL 优化器会使用这个选择性很高而体积很小的基于 url_crc 列的索引来完成查找。

> 即使有多个记录相同的索引值，查找仍然很快，只需要先比较哈希值然后根据返回的行在比较一次 url 即可。

如果对完整的 URL 字符串做索引，那样会非常慢。



唯一的缺点就是需要自己维护 hash 值，注意千万不要使用 SHA1 和 MD5 作为哈希函数，这两个函数计算出来的哈希值是非常长的字符串，会浪费大量空间且比较也很慢。这样和直接比较 URL 基本没有差别。



一般可以使用自己实现一个 64 位哈希函数，或者数据量少则直接使用 MySQL 的 CRC32() 函数。



## 2. 索引优点

* 1）索引大大减少了服务器需要扫描的数据量。
* 2）索引可以帮助服务器避免排序和临时表
* 3）索引可以将随机 I/O 变为顺序 I/O。





## 3. 高性能索引策略



* 1）**独立的列**
  * 指的是 索引列不能是表达式的一部分，也不能是函数的参数

```mysql
# 错误如下
SELECT id FROM actor WHERE actor_id +1 =5;
SELECT name FROM t WHERE TO_DAYS(CURRNET_DATE) -TO_DAYS(date_col) <= 10;
```

* 2）**前缀索引和索引选择性**
  * 索引很长的字符列，会让索引变大且慢。可以使用前面提到的 哈希索引，也可以使用前缀索引，只索引开始的部分字符，节约空间提升效率。
  * 索引选择性指 - 不重复的索引值（基数 cardinality）和总记录数的比值。索引选择性越高，在查询时就能过滤掉更多的行，效率就越高。

**选择足够长的前缀保证较高的选择性，同时又不能太长（以便节约空间）。**

对于 TEXT、BLOB 这种列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。



* 3）**多列索引**

常见错误就是为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

在一个多列 B-Tree 索引中，索引列的顺序意味着所以首先按照最左列进行排序，其次是第二列，等待。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的 ORDER BY、GROUP BY 和 DISTINCT 等子句的查询需求。



多列索引顺序的经验法则：

* 1）将选择性最高的列放到索引最前列。
  * 前提是不需要考虑排序和分组。



* 4）**聚簇索引**
  * 聚簇索引不是一组单独的索引类型，而是一组数据存储方式。

具体的细节依赖于其实现方式，但 **InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行**。

优点：

* 1）可以把相关数据保存在一起，可能会减少 I/O 次数。
* 2）数据访问更快，因为将索引和数据保存在同一个 B-Tree 中，所以从聚簇索引中获取数据通常比非聚簇索引快。
* 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

缺点：

* 1）插入速度验证依赖于插入顺序
* 2）更新聚簇索引的代价很大
* 3）插入新行或主键被更新导致需要移动行的时候，可能面临‘页分裂’问题。
* 4）可能导致全表扫描变慢





* 5）**覆盖索引**
  * 如果索引的叶子节点中已经包含要查询的数据，那么就不用回表查询了。
  * 索引一般远小于数据行，不用回表查询，可以极大减少数据访问量
  * 索引是按照顺序存储的，面会比随机 I/O 快很多



* 6）**使用索引扫描来排序**

MySQL 有两种方式可以生成有序的结果： 通过排序操作；或者按索引顺序扫描。

> 只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样是，MySQL 才能够使用索引来对结果做排序。



* 7）**冗余和重复索引**
  * MySQL 允许在相同列上创建多个索引，相应的 MySQL 需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个进行考虑，这会影响性能。



* 8）**未使用的索引**
  * 建议删除未使用的索引

* 9）**索引和锁**
  * InnoDB 只有在访问行的时候才会对其加锁，索引能够减少 InnoDB 访问的行数，从而减少锁的数量。



## 4. 案例学习

* 1）**避免多个范围条件**
  * 对于范围条件查询，MySQL 无法再使用范围列后面的其他索引列了
  * 但是对于`多个等值条件查询` 则没有这个限制

* 2）**优化排序**

对于选择性非常低的列，增加索引也不会有太大效果（如 性别）。

```mysql
SELECT <cols> FROM profiles WHERE sex='M' ORDER BY rating LIMIT 10;
```

如果需要翻页就更慢了

```mysql
SELECT <cols> FROM profiles WHERE sex='M' ORDER BY rating LIMIT 100000, 10;
```



对于这种情况可以使用**延迟关联**，通过使用覆盖索引查询需要返回的主键，再根据主键关联原表需要获得的行。这样可以减少 MySQL 扫描那些需要丢弃的行数。

```mysql
SELECT <cols> FROM profiles INNER JOIN (SELECT pk FROM profiles WHERE sex='M' ORDER BY rating LIMIT 100000, 10) AS x ON pk = pk
```



## 5. 小结

在选择索引和编写利用这些索引的查询时，有如下三个原则需要记住：

* 1）单行访问时很慢的。
* 2）按顺序访问范围数据是很快的
  * 1）顺序 I/O 不需要多次磁盘寻道
  * 2）如果服务器能按照需要顺序读取数据，就不需要额外排序操作
* 3）索引覆盖查询是很快的。



尽可能选择索引以必秒单行查找、尽可能地使用数据原生顺序以避免额外排序操作，并尽可能使用索引覆盖查询。

