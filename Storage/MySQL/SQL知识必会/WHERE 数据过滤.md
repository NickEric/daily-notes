# WHERE 数据过滤

### 基本操作

WHERE子句的基本格式是：

```mysql
SELECT ……(列名) FROM ……(表名) WHERE ……(子句条件)
```

例如

```mysql
SELECT name, hp_max FROM heros WHERE hp_max > 6000
```



### 使用通配符进行过滤

如果我们想要匹配任意字符串出现的任意次数，需要使用（%）通配符。比如我们想要查找英雄名中包含“太”字的英雄都有哪些：

```mysql
SELECT name FROM heros WHERE name LIKE '%太%'
```

**`%`代表零个或多个字符，而`_`只代表一个字符**。



### 索引问题

不过在实际操作过程中，我还是建议你尽量少用通配符，因为它需要消耗数据库更长的时间来进行匹配。即使你对LIKE检索的字段进行了索引，索引的价值也可能会失效。

**如果要让索引生效，那么LIKE后面就不能以（%）开头，**比如使用`LIKE '%太%'`或`LIKE '%太'`的时候就会对全表进行扫描。如果使用`LIKE '太%'`，同时检索的字段进行了索引的时候，则不会进行全表扫描。



### WHERE 字段索引

就是要避免全表扫描，所以我们会考虑在 WHERE 及 ORDER BY 涉及到的列上增加索引。

WHERE 增加索引是为了更快的查询。 ORDER BY 增加索引则是为了节省排序时间。

当然你也需要注意 索引是否会失效。因此除了考虑建立字段索引以外，你还需要考虑：

* 1) 不要在WHERE子句后面对字段做函数处理，同时也避免对索引字段进行数据类型转换
* 2) 避免在索引字段上使用<>，!=，以及对字段进行NULL判断（包括 IS NULL, IS NOT NULL）
* 3) 在索引字段后，慎用IN和NOT IN，如果是连续的数值，可以考虑用BETWEEN进行替换
  因为在WHERE子句中，如果对索引字段进行了函数处理，或者使用了<>,!=或NULL判断等，都会造成索引失效。

###   ORDER BY 字段索引

**在MySQL中，支持两种排序方式：FileSort和Index排序。Index排序的效率更高，**

* Index排序：索引可以保证数据的有序性，因此不需要再进行排序
* FileSort排序：一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序，效率较低。

所以使用ORDER BY子句时，应该尽量使用Index排序，避免使用FileSort排序。
当然具体优化器是否采用索引进行排序，你可以使用explain来进行执行计划的查看。
优化建议：
1、SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中避免全表扫描，ORDER BY子句避免使用FileSort排序。
当然，某些情况下全表扫描，或者FileSort排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。
2、尽量Using Index完成ORDER BY排序。
如果WHERE和ORDER BY相同列就使用单索引列；如果不同使用联合索引。
3、无法Using Index时，对FileSort方式进行调优。



索引是有序的，如果 ORDER BY 字段有索引 那么直接就省去了排序这个步骤。



### 小结

where子句WHERE 子句中`比较运算符`、`逻辑运算符`和`通配符`这三者各自作用？

* 1) 比较运算符，比较数值的大小，数值类型可以是整数，浮点数，字符串，布尔类型等等。
* 2) 逻辑运算符，定义where子句中多个条件之间的关系。
* 3) 通配符，对文本类型字段进行模糊查询。