# 索引

## 数据结构

* 二叉树
  * 树高度太高，查询效率低
* 红黑树
  * 树高度太高，查询效率低
* Hash
  * 单个查询快，但是无法满足范围查询

* B-Tree
* B+Tree

MySQL 使用的是 B-Tree 的变种，B+Tree，主要区别

* 非叶子节点不存储数据，只存索引（每个节点可以存储更多索引，降低树高度）
* 叶子节点包含所有数据
* 叶子节点用指针连接，提高区间访问性能。

## 问题

* 1）为什么 InnoDB 引擎表必须有主键？

需要根据主键来组织索引结构，没有手动指定主键时，InnoDB存储引擎会自动创建隐藏列（rowid）作为主键。

* 1）如果有显式定义的主键（PRIMARY KEY），则会选择该主键作为聚集索引
* 2）否则，选择第一个所有列都不允许为NULL的唯一索引
* 3）若前两者都没有，则InnoDB会选择内置的DB_ROW_ID作为聚集索引，命名为GEN_CLUST_INDEX

> **特别提醒：** DB_ROW_ID占用6个字节，每次自增，且是**整个实例内全局分配**。也就是说，当前实例如果有多个表都采用了内置的DB_ROW_ID作为聚集索引，则在这些表插入新数据时，他们的内置DB_ROW_ID值并不是连续的，而是跳跃的。像下面这样：
>
> ```
> t1表的ROW_ID：1、3、7、10
> t2表的ROW_ID：2、4、5、6、8、9
> ```
>
> **如果一个实例中有多个表都用到这个DB_ROW_ID的话，势必会造成并发请求的竞争/等待。**此外也可能会造成主从复制环境下，从库上relay log回放时可能会因为数据扫描机制的问题造成严重的复制延迟问题。



* 2）为什么推荐使用整形且自增的主键？

整形：索引查找过程中需要多次比较大小，整形效率高。

自增：自增的整形是连续的，如果用不连续的主键可能会出现B+Tree节点分裂（也叫页分裂）问题（B+Tree 叶子节点需要维护节点数据的顺序）。



## 联合索引

一般不推荐使用多个单字段阶段，而是推荐使用联合索引。

* 1）联合索引有多字段如何排序？

根据字段先后顺序，分别进行比对，若前面的字段无法区分大小则继续比后面的字段。

> 所以才会有**最左前缀原则**。



## 辅助索引

**辅助索引同时会存储主键索引列值**

辅助索引的值为，主键索引的值。假如主键是多个列，那么辅助索引对应的值就是多列。如果建辅助索引时，指定了主键列中的一部分列，那么辅助索引的值里就只会存储剩下的那一部分主键列。



## NULL值问题

结论：列中存在NULL则不会走索引是错误的。