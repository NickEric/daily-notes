# InnoDB Page

## 1. 概述

InnoDB Page 默认大小为 16kb；

有个选项 **innodb_fill_factor** 用于定义InnoDB page的填充率，默认值是100，但其实最高只能填充约15KB的数据，因为InnoDB会预留1/16的空闲空间。在InnoDB文档中，有这么一段话

> An innodb_fill_factor setting of 100 **leaves 1/16 of the space** in clustered index pages free for future index growth.

另外，文档中还有这样一段话

> When new records are inserted into an InnoDB clustered index, InnoDB tries to leave 1/16 of the page free for future insertions and updates of the index records. If index records are inserted in a sequential order (ascending or descending), the resulting index pages are about 15/16 full. If records are inserted in a random order, **the pages are from 1/2 to 15/16 full**.

上面这两段话，综合起来理解，就是

1. 即便 innodb_fill_factor=100，也会预留1/16的空闲空间，**用于现存记录长度扩展用**
2. 在最佳的顺序写入数据模式下，page填充率有可能可以达到15/16
3. 在随机写入新数据模式下，page填充率约为 1/2 ~ 15/16
4. 预留1/16这个规则，**只针对聚集索引的叶子节点有效**。对于聚集索引的非叶子节点以及辅助索引（叶子及非叶子）节点都没有这个规则
5. 不过 innodb_fill_factor 选项对叶子节点及非叶子节点都有效，但对存储text/blob溢出列的page无效



## 2. 页结构

 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝页结构＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

因为缺乏可靠官方文档，所以这里的描述不一定正确。

 

所谓数据库其实就是有结构的文件系统，在一般文件系统（单机or分布式）基础上做一些封装便于结构化数据增删改除。其实，普通的文件系统也可以认为是一种特殊的数据库系统，是一种典型的对象（object）存储系统。

或者从数据结构的角度来讲，就是一堆磁盘上的数据结构加上一堆在内存中的数据结构，如果提高效率，就得设计一些相辅相成的精巧数据结构，很有意思的一件事，对不对。

 

数据页是b-tree的基本单位。

通常在定义数据页时，一开始要大致分好区间，至于某个区间内的具体内容（比如page header）刚开始未必能一下子想清楚，不过没关系，一般都是需要什么加什么，但经验会告诉你，一开始应该怎样给数据结构分区，这是关键。

 

file header：

－－check sum;

－－页在表空间中的偏移（序号）；

－－pre page && next page（序号）; B+ tree的特性决定了叶子节点必须时双向链表；

－－LSN（log seqeunce number）；该页最后被修改的日至序列位置 //？

－－页类型；

－－属于哪个表空间；

page header:

－－blablabla；很多，页的身份证信息，跟人一样，纪录注入性别、籍贯、xxx

infimum record: 虚拟行纪录，纪录比页中任意主键值都小的值；

supremum record：比任何业内主键值大的值；

－－注：这是数据库系统的常用做法。比如sstable file。

user record:

free space：占坑，因为page大小固定；需要注意的是，它是个链表结构，一条纪录删除后，会加到空闲链表中；

page directory:纪录的位置索引，多条纪录公用一个directory（slot）——sparse directory，用于在页内快速查找纪录；因为是稀疏的，所以仍需要通过record自身的next指针来作具体的record查找，是不是有点类似跳表的感觉？但这里可以对sparse directory进行二分查找。

－－注：这也是数据库系统的惯用手法，sstable file有类似机制。

file trailer: 用于保证页的完整性；这里有一些技巧性的东西，不详述。一般存储系统在进行数据块读入的时候都会进行数据校验来检测数据是否corrupt。

 

＝＝＝＝＝

### directory slot

InnoDB Page 包括存储索引的非叶子节点和存储数据的叶子节点，同时也有页目录，用于加快查询（是稀疏索引）。

首先，页目录是倒序并且有序的。初始会有2个页目录，一个是infimum，一个是supremum，它们因为都在页目录中，所以各自记录的owned值（拥有的记录数）都是1。因为页目录是稀疏索引，所以每个索引不是只是指向一条记录，而是指向多条记录，所以会有owned这个值。

当我们插入了一个值，比如1的时候，槽目录会发生改变：

infi(1) supremum(2)[1]

括号内为该槽拥有的记录数，而后面方括号内的是拥有的记录的值。我们可以看见，槽还是只有2个，但是supremum记录拥有的记录变成了2，也就是新的记录1依附到了supremum记录上了。每次新增记录，都会寻找离插入记录主键最接近并比它大的槽进行依附。

我们再次插入5个值，于是槽目录会变为：

infi(1) supremum(7)[1,2,3,4,5,6]

每个槽可以拥有的记录数是有限的，范围是4-8个，除去自己，也就是3-7个记录，这个拥有数是有依据的，当达到8个的情况下，可以进行槽的分裂。当然supremum记录是没有下限的，它的范围是1-8个。

我们再次插入一个值，分裂前应当是这样：

infi(1) supremum(8)[1,2,3,4,5,6,7]

但是这儿的拥有数已经到达了上限8，于是进行一次分裂：

infi(1) 4(4)[1,2,3] supremum(4)[5,6,7]

于是我们可以看见，槽进行了分裂，变为了3个，每个槽依旧拥有4-8个记录。

### 每页记录条数

从上面我们知道，一个page最大约能存储15/16容量，扣掉用于存储page header、trailer信息，以及index header、File Segment Header、Infimum&Supremum（两条虚拟记录）等必要的固定消耗之后，实际大约只有15212字节可用于存储用户数据。

这样一来，我们就可以简单测算出一个page大约能存储多少条记录了。



另外，我们知道每条记录都要几个额外存储的数据

- DB_TRX_ID，6字节
- DB_ROLL_PTR，7字节
- Record Header，至少5字节（用上面这个测试表，只需要5字节，不同数据类型需要的header长度也不同，详见 **浅析InnoDB Record Header及page overflow**
- 因此，一条数据需要消耗 4(INT列) + 6 + 7 + 5 = 22字节
- 此外，大约每4条记录就需要一个directory slot，每个slot需要2字节
- 综上，假设可以存储N条记录，则 N*22 + N/4*2 = 15212，可求得N约等于676

**当innodb表聚集索引达到三层高时，大概可以存储几条记录？**

可以得到几点结论

- 根节点里共有两条记录，每条记录占用8字节
- 由于整型只需要4字节，因此我们可推断出指向叶子节点的指针需要占用4字节
- 每条记录同样需要5字节的record header（不同聚集索引列数据类型，需要的record header也不一样）
- 减去必要的FIL Header、Index Header等头信息后，非叶子节点可用空间约 16241 字节
- 综上，假设非叶子节点可以存储N条记录，则 N*13 + N/4*2 = 16241，可求得N约等于1203
- 既然**每个非叶子节点可存储1203条记录，每个叶子节点可存储676条记录**，则一个三层高度的InnoDB表聚集索引可以存储 1203*1203*676= 978313284，也就是**约9.7亿条记录**
- 所以说，**如果表足够“窄”的话，一个三层高的表足够存储上亿条数据，其平均搜索效率并不差，常规的存取效率也不会太差**
- 当然了，如果因为索引使用不当，导致检索效率低下，或者频繁发生锁等待，那要另当别论

## 3.分裂与合并

### 页分裂

假如第一页写满了，那么这条记录按理应该存到第二页，但是第二页也写满了呢？数据不能乱序插入。那该怎么办呢？

InnoDB将做的是（简化版）：

1. 创建一个新页。
2. 确定原始页（第10页）可以在哪里拆分（在记录级别）
3. 移动记录
4. 重新定义页之间关系

具体则是创建第三页，将第一个的数据按照一定规则分到第一页 和第三页上。

然后修改页的连接顺序，正常情况应该是 1 2 3 这样的，但是这种情况下 InnoDB会修改为  1 3 2 这样的顺序。

虽然物理上页是无序的，但是由于维护了页之间的关系，类似于链表（当前页会存放前一页和后一页的指针），所以逻辑上是有序的。

通常，我们可以说：页分裂发生在插入或者更新，并导致页错位（在许多情况下，程度不同）。

InnoDB在`INFORMATION_SCHEMA.INNODB_METRICS`表中记录了页分裂的次数。查看`index_page_splits`和`index_page_reorg_attempts/successful`指标。

一旦分裂的页创建，将其回收的唯一方法是将创建的页降至合并阈值下。当这发生时，InnoDB通过合并操作将数据从分裂页迁移走。

另外一个组织数据的方法是`OPTIMIZE TABlE`。这是一个代价比较大和长的过程，但通常是处理太多页比较稀疏的唯一方法。

### 页合并

MERGE_THRESHOLD 这个参数的默认值是页的50%，它在InnoDB页合并活动中起着非常重要的作用：



当您删除一条记录时，不会实际删除该记录，而是将记录标记为已删除，并且该记录使用的空间可回收。

当一个页删除足够多的数据，达到合并阈值（默认是页大小的50%），InnoDB开始找相邻的页（之前和之后的）查看它们是否有机会合并两个页，优化空间使用率。(相邻两个页使用率都不足50%则会进行页合并)

### 其他

另一个需要记住的是，在合并和分裂时，InnoDB在索引树上需要加一个X的闩。在繁忙的系统上，这很容易成为一个问题。这会导致索引闩争用。如果没有合并和分裂（也就是写入），只有一个单独的页，在InnoDB中被称为“乐观”更新，此时的闩为共享闩。合并和分裂被称为“悲观”更新，此时的闩为排他闩。

## 4. 疑问

**innodb page预留的1/16空闲空间做什么用的？**

凭直觉，我认为是**用于需要“增长(读cháng)/扩充”方式更新某条记录时所需，而不是用于写入新记录**。例如，c1列定义为VARCHAR(10)，第一次存储时只写了5个字节，后来做了一次更新，把它从5个字节增长到10个字节，称为**“增长”更新**。



## 5. 注意事项

还有重要一点需要记住。在InnoDB中，您不能有碎片记录，否则在页级别上，您会有一个噩梦。忽略维护表将导致IO层、内存和InnoDB buffer pool更多的负载。

必须定期重建一些表。可以使用分区或者外部工具（pt-osc）。不要让表变得很大并充满碎片。

在讨论这个主题之前，我们需要了解MySQL，有两种碎片：

- 在表中的InnoDB页完全空闲引起的碎片。
- InnoDB页未填充满（页中还有一些空闲空间）引起的碎片。

主要有三种由插入引起的碎片场景：

- 插入，然后回滚
- 插入语句失败
- 页分裂引起的碎片





原文

```text
https://mp.weixin.qq.com/s?__biz=MjM5NzAzMTY4NQ==&mid=2653932839&idx=1&sn=37200bacf8594cd3fcf4f16592b90c6e&chksm=bd3b574d8a4cde5b83f6fdfb47523ef1ce0b40a6eb89756a8e10be49de5109573d20a7560e74&scene=21#wechat_redirect
```

