# 锁

## 1. 什么是锁

 数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。



## 2. latch与lock

latch：一般称为闩锁（轻量级锁），因为其要求锁定的时间必须非常短。长时间持续会导致性能下降。在InnoDB中latch分为mutex（互斥量）、rwlock(读写锁)。目的是保证并发线程操作临界资源的正确性，通常没有死锁检测机制。

lock的对象是事务，用来锁定的是数据库的对象（表、页、行等），一般在commit或rollback后进行释放。



## 3. InnoDB存储引擎中的锁

### 1. 锁的类型

InnoDB存储引擎实现了如下两种标准的行级锁：

* 共享锁(S Lock),允许事务读取一行数据。
* 排他锁(X Lock)，允许事务删除或更新一行数据。

其中共享锁只与共享锁兼容，排他锁则与任何锁不兼容。

即事务T1获取了行r的共享锁，此时事务T2也可以继续获取行r的共享锁，事务T3要获取行r的排他锁则需要等T1、T2释放。



InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为此InnoDB存储引擎添加了意向锁。

意向锁是将锁定的对象分为多个层次，意向锁意味着事务`希望`在更细粒度上进行加锁。

InnoDB存储引擎意向锁为表级别的锁，主要是为了在事务中揭示下一行将被请求的锁类型，有两种类型：

* 意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁。
* 意向排他锁(IX Lock),事务想要获得一张表中某几行的排他锁。

### 2.  一致性非锁定读

一致性非锁定读：指的是InnoDB存储引擎通过行多版本控制的方式读取当前执行时间的数据库中行的数据。如果读取的行正在执行delete、update操作，这时读取操作不会等待行上的锁的释放，相反地，**InnoDB存储引擎会读取行的一个快照**。

由于一个行可能有不止一个快照数据，一般称为行多版本技术，由此带来的并发控制称之为多版本并发控制（MVCC）。

在read committed和repeatable read事务隔离级别下，InnoDB使用的是一致性非锁定读。 



### 3. 一致性锁定读

默认情况下，repeatable read事务隔离级别下，InnoDB使用的是一致性非锁定读。 

某些情况下用户可以显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。

InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读：

* SELECT ... FOR UPDATE (加X锁)
* SELECT ... LOCK IN SHARE MODE(加S锁)

当然了锁定读操作必须在事务中执行，事务提交时释放锁。

### 4. 外键和锁

对于外键值的更新或插入，首先需要查询父表中的记录，即SELECT父表。

且该操作使用的是`一致性锁定读`。如果使用一致性非锁定读则可能会出现子父表数据不一致问题。

会话A开启事务后删除记录A，同时会话B查询记录A，如果是一致性非锁定读则会读到快照，发现记录A还存在然后执行插入操作。最后就出现了子父表数据不一致的问题。

## 4. 锁的算法

 InnoDB存储引擎的3中行级锁算法：

* Record Lock：单个行记录上的锁；
* Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
* Next-Key Lock： Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

InnoDB对于行的查询采用 Next-Key Lock算法，采用该算法的技术叫做 Next-Key Locking，目的是解决幻影问题。

Next-Key Lock降级为Record Lock仅在查询的列是唯一索引的情况下。



## 5. 锁问题

锁只会带来3中问题：

* 1.脏读
* 2.不可重复读
* 3.丢失更新



### 1. 脏读

事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。

### 2. 不可重复读

事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致，**重点在于update和delete(锁行即可解决)**

### 3.丢失更新

* 事务T1中将行R修改为V1后未提交
* 事务T2将行R修改为V2后也未提交
* 事务T1提交
* 事务T2提交

最后行R将处于V2状态，即T1中的修改丢失了。



但是由于锁的存储这种问题不会出现，T1事务对行R加锁了，在T1事务提交前T2事务都会阻塞。

但是在程序中可能会出现另外一种情况：

* 事务T1查询行R放入本地内存显示给终端用户U1
* 事务T2也查询行R并显示给U2
* U1修改行R并提交
* U2修改并提交

同样的U1修改记录会丢失。

可以通过给查询步骤也加锁来解决问题。

事务T1查询时加排他锁，事务T2查询也加排他锁，这样事务T2就会阻塞直到U1提交了。

## 6.  阻塞

事务中的锁等待另一个事务中的锁释放资源就叫做阻塞。

InnoDB存储引擎中可以用参数`innodb_lock_wait_timeout`来控制等待时间(默认是50秒)。参数`innodb_rollback_on_timeout`来控制超时后是否进行事务回滚(默认OFF，不回滚)。



## 7. 死锁

**指的是两个或者两个以上的事务在执行过程中，因争夺资源而造成的一种相互等待的现象。**





### 1. 死锁方法

**超时**

两个事务产生死锁时，等待其中一个超时后回滚事务，这样另一个事务就可以执行了。

但若超时的事务所占权重比较大(如更新了很多行，占用了较多的undo log)，则不合适这种方法，因为回滚这个事务的时间可能比另一个事务所占用的时间还多。



**等待图**

当前数据库普遍采用等待图(wait-for graph)的方式来进行死锁检测。

较之超时的解决方案，这是一种更为主动的死锁检测方式，InnoDB存储引擎也采用这种方式。

wait-for graph要求数据库保存以下两种信息：

* 锁的信息链表
* 事务等待链表

通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，资源间相互发生等待。



## 8. 锁升级

指的是将当前锁的粒度降低。（行锁->页锁—>表锁）

**InnoDB存储引擎不存在锁升级的问题**，因为其不是根据每个记录来产生行锁的。相反其根据每个事物访问的每个页对锁进行管理，采用的是位图的方式。因此一个事务锁一个记录还是多个记录开销都是一样的。