# 事务

## 1. 认识事务

### 1. 概述

InnoDB中的事务完全符合ACID特性。原子性、一致性、隔离性、持久性。

- **原子性：**一个事务（transaction）中的所有操作，要么全部完成(**执行成功**)，要么全部不执行。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 2. 事务分类

* 扁平事务：最常见的普通事务
* 带有保存点的扁平事务：允许回滚到事务中的某个状态
* 链事务
* 嵌套事务
* 分布式事务：分布式环境下的扁平事务



## 2. 事务的实现

数据库通过原子性（A）、隔离性（I）、持久性（D）来保证一致性（C）。其中**一致性是目的，原子性、隔离性、持久性是手段**。因此数据库必须实现AID三大特性才有可能实现一致性。

- **原子性**：undo log 回滚功能保证了事务的原子性
- **一致性**：AID3个特性保证了事务的一致性，但是完整的一致性还需要配合共同完成。一致性需要区别ACID中的一致性和CAP中的一致性。
  - ACID中的一致性：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。对于这个概念，它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。
  - CAP中的一致性：是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值。
- **隔离性**：锁、mvcc和快照隔离等机制保证了事务的隔离性。数据库对于隔离级别的实现就是使用**并发控制机制**对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新，而最重要也最常见的并发控制机制，
- **持久性**：redo log重做日志保证了事务的持久性,事务提交前需要写redo log且commit的时候要写到磁盘上才算完成。



### 1. redo log

物理格式的日志，记录的是物理数据页面的修改的信息

**防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。**

### 2. undo log

逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。

> 可以认为当delete一条记录时，undo log中会记录一条对应的insert记录

**保存了事务发生之前的数据的一个版本，可以用于`回滚`，从而达到原子性。同时可以提供多版本并发控制下的读（`MVCC`），也即非锁定读。**



### 3. purge

delete和update操作可能并不直接删除原有的数据。

对于`DELETE FROM t WHERE  a=1;`可能只是把对应记录delete flag置为1并没有立即删除。

因为InnoDB存储引擎支持MVCC，所以记录不能再事务提交时立即进行处理。这时其他事务可能正在引用这行，所以InnoDB存储引擎需要保持记录之前的版本。

真正的删除操作则通过purge来执行。



### 4. group commit

在非只读事务提交之前都需要调用fsync操作以保证redo log都写入磁盘，但是磁盘效率是比较低的。

为了提高效率于是出现了group commit，即一次fsync可以确保多个事务的redo log写入磁盘。





## 3. 事务控制语句

* start transaction/begin：显式开启一个事务；
* commit：提交事务；
* rollback：回滚事务；
* savepoint  identifier：在事务中创建一个保存点，一个事务中可以有多个保存点。
  * 例如`savepoint mypoint1`
*  release savepoint identifier： 删除一个保存点
  * 例如` release savepoint mypoint1`
* rollback to [savepoint] identifier:回滚到一个保存点
  * 例如`rollback to savepoint mypoint1`
* set transaction：设置事务隔离级别（read uncommitted、read committed、repeatable read、serializable）



## 4. 事务隔离级别

ISO和ANIS SQL提供了4种事务隔离级别的标准。

* read-uncommitted
* read-committed
* repeatable-read
* serializable

**事务隔离级别是性能与一致性之间的取舍，隔离级别越高，一致性越强，性能则越低。**

InnoDB存储引擎实现的事务隔离级别功能，能够让客户端对他们想要看到的由其他事务所做的修改类型进行控制，它提供了多种不同的隔离级别，可以允许或预防在多个事务同时运行时可能出现的各类问题。

* 1.脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
* 2.不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致，**重点在于update和delete(锁行即可解决)**
* 3.幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读,**重点在于insert（需要锁表解决)**

　**不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。 **

为了解决这些问题，InnoDB存储引擎提供了4种事务隔离级别。

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读       |
| ---------------------------- | ---- | ---------- | ---------- |
| 读未提交（read-uncommitted） | 是   | 是         | 是         |
| 不可重复读（read-committed） | 否   | 是         | 是         |
| 可重复读（repeatable-read）  | 否   | 否         | 对InnoDB否 |
| 串行化（serializable）       | 否   | 否         | 否         |



## 5. 分布式事务

InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。

分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。

事务资源一般指关系型数据库系统。

> 简单来说就是可以把多台服务器上的事务组成一个全局事务。

XA是由X/Open组织提出的分布式事务的规范。XA规范主要定义了(全局)事务管理器(TM: Transaction Manager)和(局部)资源管理器(RM: Resource Manager)之间的接口。XA为了实现分布式事务，将事务的提交分成了两个阶段：也就是**2PC (tow phase commit)，XA协议就是通过将事务的提交分为两个阶段来实现分布式事务。**



## 6. 不好的事务习惯

### 1.在循环中提交

循环中提交大概这样

```go
	for i:=0;i<10000;i++{
		BEGIN
		// 逻辑代码
		INSERT INTO t VALUES(i)
		COMMIT
	}
```

假设要插入10000条数据，这样写如果出错之后前面插入的数据该怎么处理呢？而且这样性能很低。

```go
	BEGIN
        for i:=0;i<10000;i++{
            // 逻辑代码
            INSERT INTO t VALUES(i)
        }
	COMMIT
```

这样就好很多了，将所有insert放在一个事务中。



### 2. 使用自动提交



### 3. 使用自动回滚

