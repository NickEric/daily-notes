# 分布式查询及相关性算分

假设 ES 中有 3 个主分片和 3 个副本分片一共 6 个分片。用户向该 ES 集群发起查询分为多个阶段，假设用户查询从 From 开始的 Size 个文档。

### 1. Query  Then Fetch

### 1. Query 阶段

* 用户发出搜索请求到 ES 节点。节点收到请求后，会以 Coordinating 节点的身份，在 6 个主副分片中随机选择 3 个分片，发送查询请求
* 被选中的分片执行查询，**进行排序**。然后，每个分片都会返回**From + Size**个排序后的文档 id 和排序值给 Coordinating 节点。

### 2. Fetch 阶段

* Coordinating 节点 会将 Query 阶段，从每个分片中获取的排序后的文档 id 列表汇总后重新进行排序。最终选取 From 到 From + Size 个文档的 id。
* 然后以 mulit get 请求的方式，到相应的分片获取详细的文档数据。

### 3. 潜在问题

* 1） 性能问题
  * 每个分片上需要查的文档个数 = from + size
  * 最终协调节点需要处理：number_of_shards * ( from + size )
  * 深度分页时数据量很大，效率特别低
* 2）相关性算分
  * 每个分片都基于自己的分片上的数据进行相关度计算。这会导致打分偏离的情况，特别是数据量很少时。相关性算分在分片之前是相互独立的。当文档总数很少的情况下，如果主分片大于 1，主分片越多，相关性算分会越不准。



**解决算分不准的方法**

* 数据量不大的时候，可以将主分片数设置为 1
  * 当数据量足够大的时候，只要保证文档均匀分散在各个分片上，结果一般就不会出现偏差
* 使用 DFS Query Then Fetch
  * 搜索的 URL 中指定参数`_search?search_type=dfs_query_then_fetch`
  * 到每个分片把各个分片的词频和文档频率进行收集，然后完整的进行一次相关性算分，耗费更加多的 CPU 和内存，执行性能低下，一般不建议使用